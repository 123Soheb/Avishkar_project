<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binary Search Algorithm</title>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 40px;
        padding: 0;
        box-shadow: 10px 10px 10px 10px;
      }

      h1 {
        text-align: center;
        color: green;
        background-color: #f9f9f9;
        padding: 10px;
        margin-bottom: 20px;
      }

      p,
      li {
        text-indent: 50px;
        margin-left: 80px;
        padding: 10px;
        margin-right: 80px;
        text-align: justify;
        line-height: 1.6;
        transition: background-color 0.3s;
      }

      pre {
        font-family: Arial, sans-serif;
        margin-left: 60px;
        margin-right: 60px;
        padding: 10px;
        border: 2px solid #10100fe3;
        background-color: #f9f9f9;
        overflow-x: auto;
        transition: box-shadow 0.3s;
      }

      pre code {
        display: block;
        white-space: pre;
        background-color: #f1f1f1;
        border: 2px solid#22221f;
        padding: 5px;
      }

      p:hover {
        box-shadow: 10px 10px 10px 10px;
      }

      pre:hover {
        box-shadow: 10px 10px 10px 10px;
      }

      .a1 {
        font-size: 32px;
        text-align: center;
        padding: 20px;
        text-decoration: none;
        max-width: 350px;
        background: #dfe2e9e2;
        cursor: pointer;
        border: 2px solid #e3f027;
        display: block;
        border-radius: 50px;
        box-shadow: 10px 10px 10px -1px;
        color: #e3f027;
      }

      .a1:hover {
        background-color: #e3f027;
        color: #12001b;
      }
      @media (max-width: 400px) {
        body {
          font-size: 12px;
        }
        .a1 {
          font-size: 22px;
        }
        pre,
        li,
        p {
          margin-left: 0px;
          margin-right: 0px;
          border: none;
        }
      }
    </style>
  </head>
  <body>
    <h1>Binary Search Algorithm</h1>

    <p>
      In this article, we will explore the Binary Search Algorithm. Binary
      Search is an efficient searching algorithm that works particularly well on
      sorted arrays or lists. It uses a divide-and-conquer strategy to quickly
      locate a target element within the given dataset. Understanding Binary
      Search is essential for anyone dealing with search operations on sorted
      data.
    </p>
    <br /><br />
    <center><a href="binary.html" class="a1">START VISUALIZER</a></center>
    <br /><br />

    <p><span>Binary Search is preferred in scenarios where:</span></p>
    <li>The data is sorted.</li>
    <li>Efficiency and speed in searching are crucial.</li>

    <h1>Algorithm</h1>
    <pre>
        The data is sorted.
        Efficiency and speed in searching are crucial.
        Algorithm
        Binary Search is a fast search algorithm that works on sorted datasets. It uses a divide-and-conquer approach to find the target element efficiently. Here's a high-level summary of the algorithm:

        1. **Define Bounds**: Initialize two pointers, `left` and `right`, to represent the search boundaries. Initially, `left` points to the first element, and `right` points to the last element of the dataset.

        2. **Calculate Midpoint**: Find the midpoint element between `left` and `right`. Calculate `mid` as `(left + right) / 2`.

        3. **Compare with Target**: Compare the element at index `mid` with the target element.
            - If the element at `mid` matches the target, the search is successful, and the index `mid` is returned.
            - If the element at `mid` is greater than the target, update `right` to `mid - 1` to narrow the search to the left half of the dataset.
            - If the element at `mid` is less than the target, update `left` to `mid + 1` to narrow the search to the right half of the dataset.

        4. **Repeat**: Continue steps 2 and 3 until the target element is found or `left` exceeds `right`. If `left` is greater than `right`, the target element is not in the dataset, and the search ends.

        begin BinarySearch(arr, target)  
           left = 0
           right = length of arr - 1
           while left <= right
               mid = (left + right) / 2
               if arr[mid] = target
                   return mid
               else if arr[mid] > target
                   right = mid - 1
               else
                   left = mid + 1
           end while
           return -1  // Target element not found
        end BinarySearch
    </pre>
    <h1>Working of Binary Search Algorithm</h1>
    <pre>
 
        Binary Search is a highly efficient search algorithm. Here's a detailed explanation of how it works:

        1. **Define Bounds**: The algorithm begins by initializing two pointers, `left` and `right`, which represent the search boundaries within the sorted dataset. `left` initially points to the first element, and `right` points to the last element.

        2. **Calculate Midpoint**: The midpoint `mid` is calculated as `(left + right) / 2`. This divides the search space into two halves.

        3. **Compare with Target**: The element at index `mid` is compared with the target element.
            - If they match, the search is successful, and the index `mid` is returned as the position of the target element.
            - If the element at `mid` is greater than the target, the search narrows to the left half, so `right` is updated to `mid - 1`.
            - If the element at `mid` is less than the target, the search narrows to the right half, so `left` is updated to `mid + 1`.

        4. **Repeat**: Steps 2 and 3 are repeated until one of the following conditions is met:
            - The target element is found (returning its index).
            - `left` exceeds `right`, indicating that the target element is not in the dataset (returning -1).

        Binary Search's efficiency comes from its ability to halve the search space with each comparison. It has a time complexity of O(log n), making it exceptionally fast for large datasets compared to linear search algorithms.
    </pre>
  </body>
</html>
